trigger:                                            # Pipeline trigger configuration
  branches:                                         # Limit triggers to these branches
    include:                                        # Branches that trigger the pipeline
      - main                                        # Trigger on pushes to main
      - develop                                     # Trigger on pushes to develop

pool:                                               # Agent pool selection
  vmImage: 'ubuntu-latest'                          # Use latest Ubuntu hosted agent

variables:                                          # Variables used across the pipeline
- group: NugetPublishGroup                          # Variable group (NugetPublishKey, GitHubPAT, etc.)
- name: BuildConfiguration                          # Build configuration variable
  value: 'Release'                                  # Set build config to Release

steps:                                              # Steps executed by the pipeline
  - checkout: self                                  # Checkout the repository
    fetchDepth: 0                                   # Fetch full history (required by GitVersion)

  - task: UseDotNet@2                               # Install .NET SDK task
    displayName: 'Install .NET 10 SDK'              # Friendly name of the step
    inputs:                                         # Task inputs
      packageType: sdk                              # Install the SDK (not just runtime)
      version: 10.0.x                               # Use latest 10.x SDK

  - script: |                                       # Run GitVersion and emit ADO variables directly
      set -euo pipefail                             # Safer bash: exit on error/undefined vars/pipeline errors
      dotnet tool install --global GitVersion.Tool --version 6.5.1  # Install GitVersion CLI
      export PATH="$PATH:$HOME/.dotnet/tools"       # Ensure dotnet tools path is on PATH
      dotnet-gitversion /output buildserver -config gitversion.yml  # Emit ADO variables (no JSON parsing needed)
    displayName: 'Run GitVersion (emit ADO variables)'  # Step name shown in UI

  - script: |                                       # Resolve a NuGet package version with SemVer2 fallback
      set -euo pipefail                             # Safe bash mode
      RESOLVED="${GITVERSION_NUGETVERSION}"         # Prefer SemVer1-compatible NuGetVersion
      if [ -z "${RESOLVED}" ] || [ "${RESOLVED}" = "null" ]; then  # If missing or 'null'
        RESOLVED="${GITVERSION_NUGETVERSIONV2}"     # Fall back to SemVer2-compatible NuGetVersionV2 (handles prereleases)
      fi
      echo "Resolved NuGetVersion: ${RESOLVED}"     # Log the resolved version for visibility
      echo "FullSemVer: ${GITVERSION_FULLSEMVER}"   # Log FullSemVer (e.g., 1.1.7)
      echo "MajorMinorPatch: ${GITVERSION_MAJORMINORPATCH}"  # Log MajorMinorPatch (e.g., 1.1.7)
      echo "##vso[task.setvariable variable=GitVersion.NuGetVersionResolved]${RESOLVED}"  # Export resolved version for later steps
    displayName: 'Resolve package version (NuGetVersion with SemVer2 fallback)'  # Step name
  # Map pipeline variables produced by GitVersion into env vars for the script above:
    env:
      GITVERSION_NUGETVERSION: $(GitVersion.NuGetVersion)       # SemVer1-compatible version if present
      GITVERSION_NUGETVERSIONV2: $(GitVersion.NuGetVersionV2)   # SemVer2-compatible version (prerelease-friendly)
      GITVERSION_FULLSEMVER: $(GitVersion.FullSemVer)           # FullSemVer for logs/tagging
      GITVERSION_MAJORMINORPATCH: $(GitVersion.MajorMinorPatch) # Major.Minor.Patch for logs

  - task: DotNetCoreCLI@2                           # .NET restore step
    displayName: 'Restore NuGet packages'           # Step name
    inputs:                                         # Task inputs
      command: 'restore'                            # Run dotnet restore
      projects: '**/*.sln'                          # Restore all solutions

  - task: DotNetCoreCLI@2                           # .NET build step
    displayName: 'Build solution'                   # Step name
    inputs:                                         # Task inputs
      configuration: $(BuildConfiguration)          # Use Release configuration
      arguments: '--no-restore'                     # Skip restore (already done)

  - task: DotNetCoreCLI@2                           # .NET test step
    displayName: 'Run tests'                        # Step name
    inputs:                                         # Task inputs
      command: 'test'                               # Run dotnet test
      projects: '**/*.sln'                          # Test all solutions
      arguments: '--configuration $(BuildConfiguration) --no-build' # Use Release; skip build (already done)

  - task: DotNetCoreCLI@2                           # Pack NuGet package(s)
    displayName: 'Pack NuGet'                       # Step name
    condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')  # Only pack on main
    inputs:                                         # Task inputs
      command: 'pack'                               # Run dotnet pack
      configuration: $(BuildConfiguration)          # Use Release config
      arguments: '--no-build /p:PackageVersion=$(GitVersion.NuGetVersionResolved) /p:ContinuousIntegrationBuild=true'  # Use resolved version
      packagesToPack: 'Prediktor.UA.Client/Prediktor.UA.Client.csproj'      # Project to pack
      outputDir: '$(Build.ArtifactStagingDirectory)/packages/releases'      # Output folder for .nupkg

  - script: |                                       # Sanity check that the API key is available
      if [ -z "$NUGET_PUBLISH_KEY" ]; then          # If env variable is empty
        echo "NugetPublishKey is NOT set"           # Print warning
      else
        echo "NugetPublishKey is set"               # Confirm presence
      fi
    displayName: 'Check if NugetPublishKey is set'  # Step name
    env:                                            # Environment variables for this step
      NUGET_PUBLISH_KEY: $(NugetPublishKey)         # Map secret variable to env var

  - script: |
      set -euo pipefail
      shopt -s nullglob

      PKG_DIR="$(Build.ArtifactStagingDirectory)/packages/releases"
      for file in "$PKG_DIR"/*.nupkg; do
        if [[ "$file" != *.symbols.nupkg ]]; then
          echo "Pushing $file"
          dotnet nuget push "$file" --source https://api.nuget.org/v3/index.json --api-key "$NUGET_PUBLISH_KEY" --skip-duplicate
        fi
      done
    displayName: 'Push NuGet Package'
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    env:
      NUGET_PUBLISH_KEY: $(NugetPublishKey)

  - script: |                                       # Create and push a Git tag for the release
      set -euo pipefail                             # Safe bash mode
      git config --global user.email "rd_relmgr@prediktor.no"   # Configure git user email
      git config --global user.name "Build Pipeline"            # Configure git user name
      git fetch --tags --prune --force              # Ensure local tag refs are up-to-date
      TAG="$(GitVersion.FullSemVer)"                # Capture the tag value (e.g., 1.1.7)
      if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then  # If tag already exists
        echo "Tag $TAG already exists. Skipping creation."      # Avoid failure on reruns
      else
        git tag -a "$TAG" -m "Release $TAG"         # Create an annotated tag
      fi
      git push "https://$(GitHubPAT)@github.com/PrediktorAS/OPC-UA-Client.git" "$TAG"  # Push the tag using PAT auth
    displayName: 'Tag repo with latest version and push'        # Step name
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))  # Only tag on main after success
    env:                                            # Environment variables for this step
      GitHubPAT: $(GitHubPAT)                       # GitHub Personal Access Token (secret)